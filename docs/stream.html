<!DOCTYPE html>

<html>
<head>
  <title>stream.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="behavior.html">
                behavior.js
              </a>
            
              
              <a class="source" href="byte-stream.html">
                byte-stream.js
              </a>
            
              
              <a class="source" href="clock.html">
                clock.js
              </a>
            
              
              <a class="source" href="iteration.html">
                iteration.js
              </a>
            
              
              <a class="source" href="observable.html">
                observable.js
              </a>
            
              
              <a class="source" href="operators.html">
                operators.js
              </a>
            
              
              <a class="source" href="promise.html">
                promise.js
              </a>
            
              
              <a class="source" href="stream.html">
                stream.js
              </a>
            
              
              <a class="source" href="task.html">
                task.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>stream.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A stream represents either end of a buffer that transports values
asynchronously in either direction.
By convention, values are transported in one direction, and acknowledgements
are returned.</p>
<p>A stream is a promise iterator and a promise generator.
All of the kernel methods, <code>yield</code> or <code>next</code>, <code>return</code>, and <code>throw</code>,
both send and receive promises for iterations.</p>
<p>Promise streams borrow the jargon of iterators and generators but each
method is equivalent to a conventional stream method name.</p>
<ul>
<li><code>yield</code> is akin to <code>write</code>.</li>
<li><code>next</code> is akin to <code>read</code>.</li>
<li><code>yield</code> and <code>next</code> are interchangeable. The argument is written and the
return value is a promise for what will be read.</li>
<li><code>return</code> is akin to <code>close</code>.</li>
<li><code>throw</code> is akin to <code>abort</code>, <code>cancel</code>, or <code>destroy</code>.</li>
</ul>
<p>A stream is <strong>unicast</strong>, in the sense that it is a cooperation between a
single producer and consumer, mediated by the buffer to control the
throughput of both sides.</p>
<p>Since a stream is unicast, it is also <strong>cancelable</strong>.
Either side of a connection can terminate the other.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> Task = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./task"</span>);
<span class="hljs-keyword">var</span> Promise = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./promise"</span>);
<span class="hljs-keyword">var</span> Observable = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./observable"</span>);
<span class="hljs-keyword">var</span> PromiseQueue = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./promise-queue"</span>);
<span class="hljs-keyword">var</span> Iteration = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./iteration"</span>);
<span class="hljs-keyword">var</span> WeakMap = <span class="hljs-built_in">require</span>(<span class="hljs-string">"weak-map"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Every stream has a private dual, the opposite end of the stream.
For the input, there is the output; for the output, there is the input.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> duals = <span class="hljs-keyword">new</span> WeakMap();</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Every stream has a private promise queue for transporting iterations.
The stream uses its own queue to receive iterations from its dual, and uses
the dual’s queue to send iterations to its dual.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> queues = <span class="hljs-keyword">new</span> WeakMap();</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h2 id="stream">Stream</h2>
<p>Like promises, streams use the <a href="http://domenic.me/2014/02/13/the-revealing-constructor-pattern/">revealing constructor pattern</a>.</p>
<p>However, unlike promises, streams are symmetric and support bidirectional
communication.
By convention, the stream constructor creates an output stream and reveals
the methods of the input stream as arguments to a setup function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-built_in">module</span>.exports = Stream;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stream</span><span class="hljs-params">(setup, length)</span> </span>{
    <span class="hljs-keyword">var</span> buffer = Stream.buffer(length);
    setup(buffer.in.yield, buffer.in.return, buffer.in.throw);
    <span class="hljs-keyword">return</span> buffer.out;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The <code>buffer</code> constructor method of a stream creates a tangled pair of
streams, dubbed <code>in</code> and <code>out</code>.</p>
<p>The <code>buffer</code> method is analogous to <code>Promise.defer</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.buffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(length)</span> </span>{
    <span class="hljs-keyword">var</span> outgoing = <span class="hljs-keyword">new</span> PromiseQueue(); <span class="hljs-comment">// syn</span>
    <span class="hljs-keyword">var</span> incoming = <span class="hljs-keyword">new</span> PromiseQueue(); <span class="hljs-comment">// ack</span>
    <span class="hljs-keyword">var</span> input = <span class="hljs-built_in">Object</span>.create(Stream.prototype);
    <span class="hljs-keyword">var</span> output = <span class="hljs-built_in">Object</span>.create(Stream.prototype);
    duals.set(input, output);
    duals.set(output, input);
    queues.set(input, incoming);
    queues.set(output, outgoing);
    Stream_bind(input);
    Stream_bind(output);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>If the user provides a buffer length, we prime the incoming message
queue with that many iterations.
This allows the producer to stay this far ahead of the consumer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">while</span> (length != <span class="hljs-literal">null</span> &amp;&amp; length--) {
        incoming.put(<span class="hljs-keyword">new</span> Iteration());
    }
    <span class="hljs-keyword">return</span> {<span class="hljs-keyword">in</span>: input, out: output};
};</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The <code>from</code> method creates a stream from an iterable or a promise iterable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.from = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(iterable)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_yield, _return)</span> </span>{
        Promise.return(iterable)
        .invoke(<span class="hljs-string">"forEach"</span>, _yield)
        .then(_return)
        .done();
    });
};</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The kernel methods of a stream are bound to the stream so they can be passed
as free variables.
Particularly, the methods of an input stream are revealed to the setup
function of an output stream’s constructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stream_bind</span><span class="hljs-params">(stream)</span> </span>{
    stream.next = stream.next.bind(stream);
    stream.yield = stream.yield.bind(stream);
    stream.return = stream.return.bind(stream);
    stream.throw = stream.throw.bind(stream);
}

Stream.prototype.Iteration = Iteration;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h3 id="kernel-methods">Kernel Methods</h3>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>The <code>next</code> and <code>yield</code> methods are equivalent.
By convention, <code>next</code> is used to consume, and <code>yield</code> to produce,
but both methods have the same signature and behavior.
They return a promise for the next iteration from the other side of the
connection, and send an iteration with the given value to the other.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.prototype.next = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.yield(value, index);
};

Stream.prototype.yield = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, index)</span> </span>{
    <span class="hljs-keyword">var</span> dual = duals.get(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">var</span> incoming = queues.get(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">var</span> outgoing = queues.get(dual);
    outgoing.put(<span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.Iteration(value, <span class="hljs-literal">false</span>, index));
    <span class="hljs-keyword">return</span> incoming.get();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The <code>return</code> method sends a final iteration to the other side of a stream,
which by convention terminates communication in this direction normally.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.prototype.return = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{
    <span class="hljs-keyword">var</span> dual = duals.get(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">var</span> incoming = queues.get(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">var</span> outgoing = queues.get(dual);
    outgoing.put(<span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.Iteration(value, <span class="hljs-literal">true</span>));
    <span class="hljs-keyword">return</span> incoming.get();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The <code>throw</code> method sends an error to the other side of the stream,
in an attempt to break communication in this direction, and, unless the
other side handles the exception, the error should bounce back.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.prototype.throw = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> </span>{
    <span class="hljs-keyword">var</span> dual = duals.get(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">var</span> incoming = queues.get(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">var</span> outgoing = queues.get(dual);
    outgoing.put(Promise.throw(error));
    <span class="hljs-keyword">return</span> incoming.get();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h3 id="do">do</h3>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The <code>do</code> method is a utility for <code>forEach</code> and <code>map</code>, responsible for
setting up an appropriate semaphore for the concurrency limit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.prototype.do = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, errback, limit)</span> </span>{
    <span class="hljs-keyword">var</span> next;</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>If there is no concurrency limit, we are free to batch up as many jobs
as the producer can create.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (limit == <span class="hljs-literal">null</span>) {
        next = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.next()
            .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(iteration)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Before even beginning the job, we start waiting for another
value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                next.call(<span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">return</span> callback(iteration);
            }, <span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>)
        };
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>If there is a concurrency limit, we will use a promise queue as a
semaphore.  We will enqueue a value representing a resource
(undefined) for each concurrent task.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> semaphore = <span class="hljs-keyword">new</span> PromiseQueue();
        <span class="hljs-keyword">while</span> (limit--) {
            semaphore.put();
        }
        next = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Whenever a resource is available from the queue, we will start
another job.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> semaphore.get()
            .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resource)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Each job begins with waiting for a value from the iterator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.next()
                .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(iteration)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Once we have begun a job, we can begin waiting for
another job.
A resource may already be available on the queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    next.call(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>We pass the iteration forward to the callback, as
defined by either <code>forEach</code> or <code>map</code>, to handle the
iteration appropriately.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">return</span> Promise.try(callback, <span class="hljs-literal">null</span>, iteration)
                    .finally(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>And when the job is complete, we will put a resource
back on the semaphore queue, allowing another job to
start.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        semaphore.put(resource);
                    })
                }, <span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>);
            }, <span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>)
            .done(<span class="hljs-literal">null</span>, errback);
        }
    }
    next.call(<span class="hljs-keyword">this</span>);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h3 id="foreach">forEach</h3>

            </div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>The <code>forEach</code> method will execute jobs, typically in serial, and returns a
cancelable promise (<code>Task</code>) for the completion of all jobs.
The default concurrency limit is 1, making <code>forEach</code> as serial as it is for
arrays, but can be expanded by passing a number in the third argument
position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.prototype.forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, thisp, limit)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>We create a task for the result.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> result = Task.defer(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>If the task is canceled, we will propagate the error back to the
generator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.throw(error);
    }, <span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>The default concurrency for <code>forEach</code> limit is 1, making it execute
serially.
For other operators, <code>map</code> and <code>filter</code>, there is no inherent
parallelism limit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (limit == <span class="hljs-literal">null</span>) { limit = <span class="hljs-number">1</span>; }</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>We will use signals to track the number of outstanding jobs and whether
we have seen the last iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> count = Observable.signal(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">var</span> done = Observable.signal(<span class="hljs-literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>We will capture the return value in scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> returnValue;</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Using the do utility function to limit concurrency and give us
iterations, or prematurely terminate, in which case we forward the error
to the result task.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.do(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(iteration)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>If this was the last iteration, capture the return value and
dispatch the done signal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (iteration.done) {
            returnValue = iteration.value;
            done.in.yield(<span class="hljs-literal">true</span>);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Otherwise, we start a new job.
Incrementing the number of outstanding jobs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            count.in.inc();</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Kick off the job, passing the callback argument pattern familiar
to users of arrays, but allowing the task to return a promise to
push back on the producer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> Promise.try(callback, thisp, iteration.value, iteration.index)
            .finally(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>And then decrementing the outstanding job counter,
regardless of whether the job succeeded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                count.in.dec();
            })
        }
    }, result.in.throw, limit);</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>We have not completed the task until all outstanding jobs have completed
and no more iterations are available.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    count.out.equals(Observable.yield(<span class="hljs-number">0</span>)).and(done.out).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(done)</span> </span>{
        <span class="hljs-keyword">if</span> (done) {
            result.in.return(returnValue);
        }
    });
    <span class="hljs-keyword">return</span> result.out;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h3 id="map">map</h3>

            </div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>The <code>map</code> method runs jobs in parallel, taking values from this iterator and
sending them to the returned promise iterator.
There is no default limit to concurrency, but you can pass a number.
Also, the order in which values pass from the input to the output is
determined by how quickly the jobs are processed.
However, the index of the input iterations propagates to the output
iterations.
A concurrency limit of 1 will ensure that order is preserved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.prototype.map = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, thisp, limit)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>We use our own constructor so subtypes can alter behavior.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor.buffer();</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>As with <code>forEach</code>, we track the number of outstanding jobs and whether
we have seen the last iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> count = Observable.signal(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">var</span> done = Observable.signal(<span class="hljs-literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>And we will capture the return value here to pass it along to the result
stream.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> returnValue;
    <span class="hljs-keyword">this</span>.do(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(iteration)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>If this is the last iteration, track the return value and dispatch
the done signal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (iteration.done) {
            returnValue = iteration.value;
            done.in.yield(<span class="hljs-literal">true</span>);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Otherwise, start another job, first incrementing the outstanding
job counter so the result stream can’t terminate until we are
done.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            count.in.inc();</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Then pass the familiar argument pattern for map callbacks,
except allowing the job to return a promise for the result.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> Promise.try(callback, thisp, iteration.value, iteration.index)
            .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>We forward the result to the output iterator, preserving its
index if not its order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">return</span> result.in.yield(value, iteration.index);
            })
            .finally(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Regardless of whether the job succeeds or fails, we drop the
outstanding job count so the stream has an opportunity to
terminate if no more iterations are available.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                count.in.dec();
            });
        }
    }, result.in.throw, limit);</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>If no more iterations are available and all jobs are done, we can close
the output stream with the same return value as the input stream.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    count.out.equals(Observable.yield(<span class="hljs-number">0</span>)).and(done.out).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(done)</span> </span>{
        <span class="hljs-keyword">if</span> (done) {
            result.in.return(returnValue);
        }
    });
    <span class="hljs-keyword">return</span> result.out;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h3 id="filter">filter</h3>

            </div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>The filter method runs concurrent tests to determine whether to include an
iteration from the input stream on the output stream.
The regularity of the duration of the test will determine whether iterations
are likely to be processed in order, but a concurrency limit of 1 guarantees
that the input and output order will be the same.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.prototype.filter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, thisp, limit)</span> </span>{
    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor.buffer();</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>As with map and forEach, we use signals to track the termination
condition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> count = Observable.signal(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">var</span> done = Observable.signal(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">var</span> returnValue;
    <span class="hljs-keyword">this</span>.do(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(iteration)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>If this is the last iteration, we track the return value to later
forward to the output stream and note that no more iterations are
available, pending any outstanding jobs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (iteration.done) {
            returnValue = iteration.value;
            done.in.yield(<span class="hljs-literal">true</span>);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Otherwise we start another job, incrementing the outstanding job
counter and using the usual filter argument pattern.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            count.in.inc();
            <span class="hljs-keyword">return</span> Promise.try(callback, thisp, iteration.value, iteration.index)
            .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Only if the test passes do we forward the value, and its
original index, to the output stream.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (value) {
                    <span class="hljs-keyword">return</span> result.in.yield(iteration.value, iteration.index);
                }
            })
            .finally(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Regardless of whether the test ran without error, we note
that the job is done.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                count.in.dec();
            });
        }
    }, result.in.throw, limit);
    <span class="hljs-comment">/* when (count == 0 &amp;&amp; done) */</span>
    count.out.equals(Observable.yield(<span class="hljs-number">0</span>)).and(done.out).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(done)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>When there are no more outstanding jobs and the input has been
exhausted, we forward the input return value to the output stream.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (done) {
            result.in.return(returnValue);
        }
    });
    <span class="hljs-keyword">return</span> result.out;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <h3 id="reduce">reduce</h3>

            </div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>The <code>reduce</code> method runs concurrent jobs to acrete values from the input
stream until only one value remains, returning a cancelable promise (task)
for that last value.</p>
<p>Yet to be ported.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-comment">/* TODO reduce, some, every */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <h3 id="fork">fork</h3>

            </div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>The fork method creates an array of streams that will all see every value
from this stream.
All of the returned streams put back pressure on this stream.
This stream can only advance when all of the output streams have advanced.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Stream.prototype.fork = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(length)</span> </span>{
    length = length || <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> buffers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length).map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.constructor.buffer();
    }, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">var</span> inputs = buffers.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
        <span class="hljs-keyword">return</span> buffer.in;
    });
    <span class="hljs-keyword">var</span> outputs = buffers.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
        <span class="hljs-keyword">return</span> buffer.out;
    });
    <span class="hljs-keyword">this</span>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, index)</span> </span>{
        <span class="hljs-keyword">return</span> Promise.all(inputs.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(input)</span> </span>{
            <span class="hljs-keyword">return</span> input.yield(value, index);
        }));
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{
        <span class="hljs-keyword">return</span> Promise.all(inputs.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(input)</span> </span>{
            <span class="hljs-keyword">return</span> input.return(value);
        }));
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> </span>{
        <span class="hljs-keyword">return</span> Promise.all(inputs.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(input)</span> </span>{
            <span class="hljs-keyword">return</span> input.throw(value);
        }));
    }).done();
    <span class="hljs-keyword">return</span> outputs;
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
